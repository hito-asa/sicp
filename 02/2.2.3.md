### 2.2.3 公認インターフェイスとしての並び

公認インターフェイス、パブリックインターフェイス的な意味合いだろうか。
filter-mapしてreduce的な処理
```scheme
(define (sum-odd-square tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (* tree tree) 0))
        (else (+ (sum-odd-square (car tree))
                 (sum-odd-square (cdr tree))))))

(sum-odd-square (list (list 1 2) (list 3 4)))
; => 10
```

同様に、リスト生成してmapしてfilterする処理
```scheme
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

(define (even-fibs n)
  (define (next k)
    (if (> k n)
        (list)
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))

(even-fibs 10)
; => (0 2 8 34)
```

アキュムレータのくだりと説明がわけわからんけどfor式的なストリーム処理がイメージされる

#### 並びの演算

map（これは組み込み）, filter, accumlate（これはfold的な）, リストの生成
```scheme
(define (filter pred seq)
  (cond ((null? seq) (list))
        ((pred (car seq))
         (cons (car seq)
               (filter pred (cdr seq))))
        (else (filter pred (cdr seq)))))

(filter odd? (list 1 2 3 4 5))
; => (1 3 5)

(define (accumlate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumlate op init (cdr seq)))))

(accumlate + 0 (list 1 2 3 4 5))
; => 15
(accumlate * 1 (list 1 2 3 4 5))
; => 120
(accumlate cons (list) (list 1 2 3 4 5))
; => (1 2 3 4 5)

(define (enumerate-interval low high)
  (if (> low high)
      (list)
      (cons low (enumerate-interval (+ 1 low) high))))

(enumerate-interval 2 7)
; => (2 3 4 5 6 7)

(define (enumerate-tree tree)
  (cond ((null? tree) (list))
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

(enumerate-tree (list 1 (list 2 (list 3 4) 5)))
; => (1 2 3 4 5)
```

上の定義を使ってsum-odd-squareとeven-fibsを実装、チェインするところは直書きで
```scheme
(define (sum-odd-squares tree)
  (accumlate +
             0
             (map (lambda (x) (* x x))
                  (filter odd?
                          (enumerate-tree tree)))))

(sum-odd-squares (list 1 (list 2 (list 3 4) 5)))
; => 35

(define (even-fibs n)
  (accumlate cons
             (list)
             (filter even?
                     (map fib
                          (enumerate-interval 0 n)))))

(even-fibs 10)
; => (0 2 8 34)
```

list-fib-squares, product-of-squares-of-odd-elements, salary-of-highest-paid-programmerは処理のパーツの入れ替えだけ（書くのめんどい）

listを公認インターフェイスとして様々な処理の入出力に用いる、暗黙の公認インターフェイスみたいな意味合いっぽい。  
rubyでのhashみたいな意味合いか。型が無いからご苦労様です的な感じがする。

#### ex 2.33

accumlate万能だ！
```scheme
(define (mymap p seq)
  (accumlate (lambda (x y) (cons (p x) y)) (list) seq))

(mymap (lambda (x) (* x x)) (list 1 2 3 4))
; => (1 4 9 16)

(define (myappend seq1 seq2)
  (accumlate cons seq2 seq1))

(myappend (list 1 2 3) (list 4 5 6))
; => (1 2 3 4 5 6)

(define (mylength seq)
  (accumlate (lambda (x y) (+ y 1)) 0 seq))

(mylength (list 1 2 3 4))
; => 4
```

#### ex 2.34

Horner法の説明はajiyoshiさんのやつがわかりやすい。  
http://d.hatena.ne.jp/ajiyoshi/20080812/1218528367

accumulateどうこうは置いといて、計算量が少ないらしい。

```scheme
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
; => 79
```

定義のまま、次数の低い項の値 + (x * 上位の項全体の値)を入れたら動いた。

#### ex 2.35

count-leavesのaccumulate版  
treeをフラットなlistにしてしまえば楽
```scheme
(define (enumerate-tree tree)
  (cond ((null? tree) (list))
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

(define (count-leaves tree)
  (accumulate (lambda (l r) (+ r 1))
              0
              (enumerate-tree tree)))

(count-leaves (list 1 3 (list 1 2 3) 5 0 1))
; => 8
```

あるいは足し合わせる際に再帰的に見てもいい
```scheme
(define (count-leaves tree)
  (accumulate (lambda (l r) (if (pair? l)
                                (+ r (count-leaves l))
                                (+ r 1)))
              0
              tree))

(count-leaves (list 1 3 (list 1 2 3) 5 0 1))
; => 8
```

でも問題はリスト生成時にmap使えとのことなので  
リスト内の各項目の数を数えるようにする
```scheme
(define (count-leaves tree)
  (accumulate (lambda (l r) (+ l r))
              0
              (map (lambda (subtree) (if (pair? subtree)
                                         (count-leaves subtree)
                                         1)) tree)))

(count-leaves (list 1 3 (list 1 2 3) 5 0 1))
; => 8
```

