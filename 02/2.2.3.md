### 2.2.3 公認インターフェイスとしての並び

公認インターフェイス、パブリックインターフェイス的な意味合いだろうか。
filter-mapしてreduce的な処理
```scheme
(define (sum-odd-square tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (* tree tree) 0))
        (else (+ (sum-odd-square (car tree))
                 (sum-odd-square (cdr tree))))))

(sum-odd-square (list (list 1 2) (list 3 4)))
; => 10
```

同様に、リスト生成してmapしてfilterする処理
```scheme
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

(define (even-fibs n)
  (define (next k)
    (if (> k n)
        (list)
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))

(even-fibs 10)
; => (0 2 8 34)
```

アキュムレータのくだりと説明がわけわからんけどfor式的なストリーム処理がイメージされる

#### 並びの演算

map（これは組み込み）, filter, accumlate（これはfold的な）, リストの生成
```scheme
(define (filter pred seq)
  (cond ((null? seq) (list))
        ((pred (car seq))
         (cons (car seq)
               (filter pred (cdr seq))))
        (else (filter pred (cdr seq)))))

(filter odd? (list 1 2 3 4 5))
; => (1 3 5)

(define (accumlate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumlate op init (cdr seq)))))

(accumlate + 0 (list 1 2 3 4 5))
; => 15
(accumlate * 1 (list 1 2 3 4 5))
; => 120
(accumlate cons (list) (list 1 2 3 4 5))
; => (1 2 3 4 5)

(define (enumerate-interval low high)
  (if (> low high)
      (list)
      (cons low (enumerate-interval (+ 1 low) high))))

(enumerate-interval 2 7)
; => (2 3 4 5 6 7)

(define (enumerate-tree tree)
  (cond ((null? tree) (list))
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

(enumerate-tree (list 1 (list 2 (list 3 4) 5)))
; => (1 2 3 4 5)
```

上の定義を使ってsum-odd-squareとeven-fibsを実装、チェインするところは直書きで
```scheme
(define (sum-odd-squares tree)
  (accumlate +
             0
             (map (lambda (x) (* x x))
                  (filter odd?
                          (enumerate-tree tree)))))

(sum-odd-squares (list 1 (list 2 (list 3 4) 5)))
; => 35

(define (even-fibs n)
  (accumlate cons
             (list)
             (filter even?
                     (map fib
                          (enumerate-interval 0 n)))))

(even-fibs 10)
; => (0 2 8 34)
```

list-fib-squares, product-of-squares-of-odd-elements, salary-of-highest-paid-programmerは処理のパーツの入れ替えだけ（書くのめんどい）

listを公認インターフェイスとして様々な処理の入出力に用いる、暗黙の公認インターフェイスみたいな意味合いっぽい。  
rubyでのhashみたいな意味合いか。型が無いからご苦労様です的な感じがする。

#### ex 2.33

accumlate万能だ！
```scheme
(define (mymap p seq)
  (accumlate (lambda (x y) (cons (p x) y)) (list) seq))

(mymap (lambda (x) (* x x)) (list 1 2 3 4))
; => (1 4 9 16)

(define (myappend seq1 seq2)
  (accumlate cons seq2 seq1))

(myappend (list 1 2 3) (list 4 5 6))
; => (1 2 3 4 5 6)

(define (mylength seq)
  (accumlate (lambda (x y) (+ y 1)) 0 seq))

(mylength (list 1 2 3 4))
; => 4
```

#### ex 2.34

Horner法の説明はajiyoshiさんのやつがわかりやすい。  
http://d.hatena.ne.jp/ajiyoshi/20080812/1218528367

accumulateどうこうは置いといて、計算量が少ないらしい。

```scheme
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
; => 79
```

定義のまま、次数の低い項の値 + (x * 上位の項全体の値)を入れたら動いた。

#### ex 2.35

count-leavesのaccumulate版  
treeをフラットなlistにしてしまえば楽
```scheme
(define (enumerate-tree tree)
  (cond ((null? tree) (list))
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

(define (count-leaves tree)
  (accumulate (lambda (l r) (+ r 1))
              0
              (enumerate-tree tree)))

(count-leaves (list 1 3 (list 1 2 3) 5 0 1))
; => 8
```

あるいは足し合わせる際に再帰的に見てもいい
```scheme
(define (count-leaves tree)
  (accumulate (lambda (l r) (if (pair? l)
                                (+ r (count-leaves l))
                                (+ r 1)))
              0
              tree))

(count-leaves (list 1 3 (list 1 2 3) 5 0 1))
; => 8
```

でも問題はリスト生成時にmap使えとのことなので  
リスト内の各項目の数を数えるようにする
```scheme
(define (count-leaves tree)
  (accumulate (lambda (l r) (+ l r))
              0
              (map (lambda (subtree) (if (pair? subtree)
                                         (count-leaves subtree)
                                         1)) tree)))

(count-leaves (list 1 3 (list 1 2 3) 5 0 1))
; => 8
```

#### ex 2.36

リスト内の先頭だけをとったリストを作ってaccumulateしていく
```scheme
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      (list)
      (cons (accumulate op init (map (lambda (seq) (car seq)) seqs))
            (accumulate-n op init (map (lambda (seq) (cdr seq)) seqs)))))

(accumulate-n + 0 (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
; => (22 26 30)
```

#### ex 2.37

これvはベクタとして、wに何を渡せばいいんでしょうね・・・  
下記式の定義を見る限り、ベクタvの各要素をベクタwの各要素と掛けあわせて総和を取る感じ。wもベクタ。  
（ここは、実際に式を書いて値を入れたりしてようやくわかりました）
```scheme
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq)
          (accumulate op init (cdr seq)))))

(define (dot-product v w)
  (accumlate + 0 (map * v w)))

(dot-product (list 1 2 3) (list 4 5 6))
; => 4 + 10 + 18 = 32
```

Σ<sub>i</sub>v<sub>i</sub>w<sub>i</sub> だ。

次は t<sub>i</sub> = Σ<sub>j</sub>m<sub>ij</sub>v<sub>j</sub> なので行の総和か列の総和のベクタが答えっぽいがどっちだろう。  
行ということにして
```scheme
(define (matrix-*-vector m v)
  (map (lambda (row) (dot-product row v)) m))

(matrix-*-vector (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) (list 1 2 3))
; => ((1 + 4 + 9) (4 + 10 + 18) (7 + 16 + 27)) = (14 32 50)
```

行で正解っぽいです。列だとこんなにシンプルに書けない。

matrix-x-matrixは飛ばしてtranspose  
ググるとtransposeは転置行列らしい。  
http://ja.wikipedia.org/wiki/%E8%BB%A2%E7%BD%AE%E8%A1%8C%E5%88%97  
この定義に従うと簡単。
```scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      (list)
      (cons (accumulate op init (map (lambda (seq) (car seq)) seqs))
            (accumulate-n op init (map (lambda (seq) (cdr seq)) seqs)))))

(define (transpose mat)
  (accumulate-n cons (list) mat))

(transpose (list (list 1 2 3 4) (list 4 5 6 6) (list 6 7 8 9)))
; => ((1 4 6) (2 5 7) (3 6 8) (4 6 9))
```

次は p<sub>ij</sub> = Σ<sub>k</sub>m<sub>ik</sub>n<sub>kj</sub> なので・・・これは図解しないと説明できない。

```scheme
(define (matrix-x-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (row) (matrix-*-vector cols row)) m)))

(matrix-x-matrix (list (list 1 2 3) (list 4 5 6) (list 7 8 9)) (list (list 7 8 9) (list 1 2 3) (list 4 5 6)))
; => ((21 27 33) (57 72 87) (93 117 141))
```

たぶんあってる。
