### 2.2.1 並びの表現

```scheme
(cons 1 (cons 2 (cons 3 (cons 4 (list)))))
; => (1 2 3 4)

(list 1 2 3 4)
; => (1 2 3 4)

(define 1to4 (list 1 2 3 4))

(car 1to4)
; => 1

(cdr 1to4)
; => (2 3 4)

(car (cdr 1to4))
; => 2
```

#### リスト演算

インデックスを指定して取り出し

```scheme
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define squares (list 1 4 9 16 25))

(list-ref squares 3)
; => 16
```

長さ

```scheme
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(length (list 1 2 3 4 5))
; => 5

; 反復的バージョン
(define (length items)
  (let iter ((l items) (n 0))
            (if (null? l)
                n
                (iter (cdr l) (+ n 1)))))

(length (list 1 2 3 4 5))
; => 5
```

結合

```scheme

```


#### ex 2.18

```scheme
(define (reverse l)
  (let iter ((org l) (dst ()))
            (if (null? org)
                dst
                (iter (cdr org) (cons (car org) dst)))))
```

