# SICP勉強会 2/18
- 今日の範囲 => P1 - P14

## ざっと概要
* 式と評価のお話
    * 
* 

## 問題1.1
    10
=> 10

    (+ 5 3 4)
=> 12

    (- 9 1)
=> 810

    (/ 6 2)
=> 3

    (+ (* 2 4) (- 4 6))
=> (+ 8 -2) => 6

    (define a 3)
=> a = 3

    (definve b (+ a 1))
=> b = 4

    (+ a b (* a b))
=> (+ 7 12) => 19

    (if (and (> b a) (< b (* a b)))
        b
        a)
=> (if (and #t #t) 4 3) => 4

    (cond ((= a 4) 6)
          ((= b 4) (+ 6 7 a))
          (else 25))
=> (+ 6 7 a) => 16

    (+ 2 (if (> b a) b a))
=> (+ 2 b) => 6

    (* (cond ((> a b) a)
             ((< a b) b)
             (else -a))
       (+ a 1))
=> (* b 4) => 16

##問題1.2
    (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

##問題1.3
    (define (sum-max2 x y z)
      (cond ((and (>= x z) (>= y z)) (+ x y))
            ((>= x z) (+ x z))
            (else (+ y z))))

##問題1.4
    (define (a-plus-abs-b a b)
      ((if (> b 0) + -) a b))

if式はbの値に応じて単行演算子+/-が返り、そこにaとbが適用される

##問題1.5
    (define (p) (p))

    (define (test x y)
      (if (= x 0)
          0
          y))

    (test 0 (p))

関数pが無限再帰。式 (test 0 (p))において関数testの評価前に関数pが評価されるかどうかが異なる。正規順序であれば関数pの評価は遅延され、0が返る。作用的順序であれば関数pが先に評価され無限再帰となる。

##問題1.6
    (define (new-if predicate then-clause else-clause)
      (cond (predicate then-clause)
            (else else-clause)))

    (new-if (= 2 3) 0 5)
=> 5

    (new-if (= 1 1) 0 5)
=> 0

    (define (sqrt-iter guess x)
      (new-if (good-enough? guess x)
              guess
              (sqrt-iter (improve guess x)
                         x)))

new-ifは作用的順序で評価されるため、渡された式が先に評価される。sqrt-iterが評価され続け無限再帰となる。

##問題1.7
    (define (sqrt-iter guess x)
      (if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
    (define (improve guess x)
      (average guess (/ x guess)))
    (define (average x y)
      (/ (+ x y) 2))
    (define (good-enough? guess x)
      (< (abs (- (square guess) x)) 0.001))
    (define (square x)
      (* x x))
    (define (sqrt x) 
      (sqrt-iter 1.0 x))

変化率見る奴

    (define (good-enough? old-guess new-guess)
      (< (abs (/ (- old-guess new-guess) old-guess)) 0.001))
    (define (sqrt-iter guess x)
      (define improved (improve guess x))
        (if (good-enough? guess improved)
            guess
            (sqrt-iter improved x)))

変化値見る奴

    (define (good-enough? old-guess new-guess)
              (< (abs (- old-guess new-guess)) 0.001))
    (define (sqrt-iter guess x)
      (define improved (improve guess x))
        (if (good-enough? guess improved)
            guess
            (sqrt-iter improved x)))

##問題1.8
    (define (improve guess x)
      (/ (+ (/ x (square guess)) (* 2 guess)) 3))
    (define (good-enough? guess x)
      (< (abs (- (cube guess) x)) 0.001))
    (define (cube x)
      (* x x x))

もしくは

    (define (good-enough? old-guess new-guess)
      (< (abs (- old-guess new-guess)) 0.001))

